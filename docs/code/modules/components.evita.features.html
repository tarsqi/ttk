<html>
<head>
<link href="../css/module.css" rel="stylesheet" type="text/css">
<script language="JavaScript" type="text/JavaScript">
<!--
function view_code(id) {
  var newurl = "../functions/" + id + ".html";
  var w = window.open(newurl,"source code","width=770,height=600,
                      scrollbars=yes,resizable=yes");
  w.xopener = window;
}
//-->
</script>
</head>
<body>
<a href=../index.html>index</a>

<div class="title">module components.evita.features</div>

<pre>
<a href=#AChunkFeatures>AChunkFeatures</a>
<a href=#ChunkFeatures>ChunkFeatures</a>
<a href=#NChunkFeatures>NChunkFeatures</a>
<a href=#VChunkFeatures>VChunkFeatures</a>
<a href=#VChunkFeaturesList>VChunkFeaturesList</a>
</pre>

<pre>
This module contains classes that add grammatical features to NounChunks,
VerbChunks and AdjectiveTokens. The grammatical features drive part of the event
recognition.</pre>


<a name="AChunkFeatures"/><div class="section">class AChunkFeatures</div>
<pre>
<strong>Inherits from: <a href=components.evita.features.html#ChunkFeatures>ChunkFeatures</a></strong></strong>

Contains the grammatical features for an AdjectiveToken. There is a
little naming disconnect here since we call these chunk features.</pre>

<blockquote>
<h3>Public Functions</h3>
<pre>
<div class=function>__init__(self, adjectivetoken, verbfeatures=None)</div>
Initialize with an AdjectiveToken and use default values for most instance
variables, but percolate grammatical features from the copular verb if
they were handed in.</pre>
<pre>
<div class=function>getEventClass(self)</div>
Return I_STATE if the head is on a short list of intentional state
adjectives, return STATE otherwise.</pre>
</blockquote>

<a name="ChunkFeatures"/><div class="section">class ChunkFeatures</div>
<pre>

The subclasses of this class are used to add grammatical features to a
NounChunk, VerbChunk or AdjectiveToken. It lives in the features variable
of instances of those classes.</pre>

<blockquote>
<h3>Public Functions</h3>
<pre>
<div class=function>__init__(self, category, chunk_or_token, verbfeatures=None)</div>
Common initialization for AChunkFeatures, NChunkFeatures and
VChunkFeatures.</pre>
<pre>
<div class=function>__str__(self)</div>
</pre>
<pre>
<div class=function>add_verb_features(self, verbfeatures)</div>
Set some features (tense, aspect, modality and polarity) to the values of
those features on the governing verb.</pre>
<pre>
<div class=function>as_verbose_string(self)</div>
Debugging method to print the ChunkFeatures and its features.</pre>
<pre>
<div class=function>print_vars(self)</div>
Debugging method to print all variables.</pre>
</blockquote>

<a name="NChunkFeatures"/><div class="section">class NChunkFeatures</div>
<pre>
<strong>Inherits from: <a href=components.evita.features.html#ChunkFeatures>ChunkFeatures</a></strong></strong>

Contains the grammatical features for a NounChunk.</pre>

<blockquote>
<h3>Public Functions</h3>
<pre>
<div class=function>__init__(self, nounchunk, verbfeatures=None)</div>
Initialize with a NounChunk and use default values for most instance
variables.</pre>
<pre>
<div class=function>getEventClass(self)</div>
Get the event class for the ChunkFeatures. For nominals, the event
class is always OCCURRENCE.</pre>
<pre>
<div class=function>getEventLemma(self)</div>
Return the lemma from the head of the chunk. If there is no head or
the head has no lemma, then build it from the text using a stemmer.</pre>
</blockquote>

<a name="VChunkFeatures"/><div class="section">class VChunkFeatures</div>
<pre>
<strong>Inherits from: <a href=components.evita.features.html#ChunkFeatures>ChunkFeatures</a></strong></strong>

Contains the grammatical features for a VerbChunk. Applies some feature
rules from the evita library in the course of setting tense and aspect
features. Also has some methods that test whether the features indicate
whether the node is of a particular kind (for example, nodeIsbecome).</pre>

<blockquote>
<h3>Public Functions</h3>
<pre>
<div class=function>__init__(self, verbchunk, tCh, negMk, infMk, advPre, advPost)</div>
Initialize with a verb chunk and the lists handed in from the
VChunkFeaturesList object.</pre>
<pre>
<div class=function>__str__(self)</div>
</pre>
<pre>
<div class=function>apply_feature_rules(self)</div>
Returns a triple of TENSE, ASPECT and CATEGORY given the tokens of
the chunk, which are stored in self.trueChunk. Selects the rules
relevant for the length of the chunk and applies them. Returns None if
no rule applies.</pre>
<pre>
<div class=function>as_short_string(self)</div>
</pre>
<pre>
<div class=function>as_verbose_string(self)</div>
</pre>
<pre>
<div class=function>getEventClass(self)</div>
Return the event class for the nominal, using the regelar expressions
in the library.</pre>
<pre>
<div class=function>getHead(self)</div>
Return the head, which is the last element of the core in
self.trueChunk, return None if there is no such core.</pre>
<pre>
<div class=function>getModality(self)</div>
</pre>
<pre>
<div class=function>getPolarity(self)</div>
</pre>
<pre>
<div class=function>getPreHead(self)</div>
Return the element before the head, which is the last element of the
core in self.trueChunk, return None if there is no such element.</pre>
<pre>
<div class=function>isAuxVerb(self)</div>
Return True if the head is an auxiliary verb.</pre>
<pre>
<div class=function>is_be(self)</div>
</pre>
<pre>
<div class=function>is_become(self)</div>
</pre>
<pre>
<div class=function>is_continue(self)</div>
</pre>
<pre>
<div class=function>is_do_auxiliar(self)</div>
</pre>
<pre>
<div class=function>is_future_going_to(self)</div>
</pre>
<pre>
<div class=function>is_have(self)</div>
</pre>
<pre>
<div class=function>is_keep(self)</div>
</pre>
<pre>
<div class=function>is_modal(self)</div>
</pre>
<pre>
<div class=function>is_past_used_to(self)</div>
</pre>
<pre>
<div class=function>is_wellformed(self)</div>
Return True if the verb features well-formed, that is, there is
content in the trueChunks core feature and there is a head.</pre>
<pre>
<div class=function>normalizeHave(self, form)</div>
</pre>
<pre>
<div class=function>normalizeMod(self, form)</div>
</pre>
<pre>
<div class=function>pp(self, verbose=False)</div>
</pre>
<pre>
<div class=function>set_tense_and_aspect(self)</div>
Sets the tense and aspect attributes by overwriting the default
values with results from the feature rules in FEATURE_RULES. If no
feature rules applied, create a throw-away features list for the head
and use the features from there (which might still be defaults).</pre>
</blockquote>

<a name="VChunkFeaturesList"/><div class="section">class VChunkFeaturesList</div>
<pre>

This class is used to create a list of VChunkFeatures instances. What
it does is (1) collecting information from a VerbChunk or a list of Tokens,
(2) move this information into separate bins depending on the type of items
in the source, (3) decide whether we need more than one instance for some
input, and (4) create a list of VChunkFeatures.

On initialization, an instance of NChunkFeatures is given a NounChunk, but a
VChunkFeaturesList is given a VerbChunk or a list of Tokens (or maybe
other categories as well). VerbChunks are different from NounChunks in that
there can be more than one VChunkFeatures instance for a single
VerbChunk. This is not very common, but it happens for example in

   "More problems in Hong Kong for a place, for an economy, that many
    experts [thought was] once invincible."

where "thought was" ends up as one verb chunk, but we get two features sets.

Another difference is that sometimes a VChunkFeatures instance is created
for a sequence that includes tokens to the right of the VerbChunk, for
example in

   "All Arabs [would have] [to move] behind Iraq."

where there are two adjacent VerbChunks. With the current implementation,
when processing [would have], we end up creating VChunkFeatures instances
for "would have" and "would have to move", and then, when dealing with "to
move", we create a VChunkFeatures instance for "to move".

TODO: check whether "would have" and "to move" should be ruled out
TODO: check why "to move" is not already ruled out through the flag

Note that in both cases, the root of the issue is that the chunking is not
appropriate for Evita.

TODO: consider updating the Chunker and simplifying the code here.</pre>

<blockquote>
<h3>Public Functions</h3>
<pre>
<div class=function>__getitem__(self, index)</div>
</pre>
<pre>
<div class=function>__init__(self, verbchunk=None, tokens=None)</div>
Initialize several kinds of lists, distributing information from the
VerbChunk or list of Tokens that is handed in on initialization and
create a list of VChunkFeatures instances in self.featuresList.</pre>
<pre>
<div class=function>__len__(self)</div>
</pre>
<pre>
<div class=function>__str__(self)</div>
</pre>
<pre>
<div class=function>print_ChunkLists(self)</div>
</pre>
</blockquote>
<blockquote>
<h3>Private Functions</h3>
<pre>
<div class=function>_addInCurrentSublist(self, sublist, element)</div>
Add the element to the current element (that is, the last element) in
sublist. The elements of the sublist are lists themselves.</pre>
<pre>
<div class=function>_addInPreviousSublist(self, sublist, element)</div>
Add the element to the previous element (that is, the penultimate
element) in sublist. The elements of the sublist are lists themselves.</pre>
<pre>
<div class=function>_distributeNode_ADV(self, item, tempNodes, itemCounter)</div>
Just add the adverb to an adverb list, the trick is to figure out which list
to add it. Factors are the location of the item in the tempNodes list
and the pos tags of the elements following the item.</pre>
<pre>
<div class=function>_distributeNode_MD(self, item)</div>
Add the modal element to the core list.</pre>
<pre>
<div class=function>_distributeNode_NEG(self, item)</div>
Do not add the negation item to the core in self.trueChunkLists, but add it
to the list with negation markers.</pre>
<pre>
<div class=function>_distributeNode_TO(self, item, itemCounter)</div>
If the item is the first one, just add the item to the infinitive markers
list. Otherwise, see if the last element in the core is one of a small
group ('going', 'used' and forms of 'have'), if it is, add the element to the
core, if not, do nothing at all.</pre>
<pre>
<div class=function>_distributeNode_V(self, item, tempNodes, itemCounter)</div>
Add a verb to the lists. This takes one of two actions, depending on the kind
of verb we are dealing with and on whether it is followed by TO.</pre>
<pre>
<div class=function>_distributeNodes(self)</div>
Distribute the item's information over the lists in the
VChunkFeaturesLists.</pre>
<pre>
<div class=function>_generate_features_list(self)</div>
</pre>
<pre>
<div class=function>_initialize_lists(self)</div>
Initializes the lists that contain items (Tokens) of the chunk. Since
one chunk may spawn more than one VChunkFeatures instance, these
lists are actually lists of lists.</pre>
<pre>
<div class=function>_initialize_nodes(self)</div>
Given the VerbChunk or a list of Tokens, set the nodes variable to
either the daughters of the VerbChunk or the list of Tokens. Also sets
node and tokens, where the first one has the VerbChunk or None (this is
so we can hand the chunk to VChunkFeatures instance, following
ChunkFeatures behaviour), and where the second one is the list of Tokens
or None.</pre>
<pre>
<div class=function>_item_is_followed_by_TO(self, tempNodes, itemCounter)</div>
Return True if one of the next two tokens is TO, return False otherwise.</pre>
<pre>
<div class=function>_treatMainVerb(self, item, tempNodes, itemCounter)</div>
Add a main verb to the trueChunks list. That is all that is done when the
item is followed by adverbs only. In other cases, we have a chunk which
has two subchunks and _updateChunkLists is called to introduce the
second chunk. This is to deal with cases like 'might consider filing',
where we want to end up with two events.</pre>
<pre>
<div class=function>_updateChunkLists(self)</div>
Append an empty list to the end of all lists maintained in the
VChunkFeaturesList and update the counter.</pre>
</blockquote>

<div class="section">module functions</div>
<pre>
<div class=function>debug(text, newline=True)</div>
</pre>
<pre>
<div class=function>getPOSList(constituents)</div>
Returns a list of parts-of-speech from the list of constituents, typically
the constituents are instances of NounChunk, VerbChunk or Token. Used for
debugging purposes.</pre>
<pre>
<div class=function>getWordList(constituents)</div>
Returns a list of words from the list of constituents, typically the
constituents are instances of NounChunk, VerbChunk or Token. Used for
debugging purposes.</pre>
<pre>
<div class=function>getWordPosList(constituents)</div>
Returns a list of word/POS for all constituents.</pre>
