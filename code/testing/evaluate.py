"""evaluate.py

Script to create a system response for a given gold standard and then compare
the system response to that gold standard.

USAGE:

There are two invocations:

$ python evaluate.py --run-system --gold DIR1 --system DIR2 (--limit INT)
$ python evaluate.py --compare --gold DIR1 --system DIR2 (--limit INT)

In the first invocation, the scripts takes the gold standard files in DIR1 and
for each file creates a system file that does not have the gold standard tags
but the tags generated by the system. The files in DIR1 all need to be TTK
files.

In the second invocation, the script compares the system results to the gold
standard. Both invocations have an optional limit parameter which caps the
number of files processed from the directory. If no limit is given all files
will be processed.

"""

import os, sys, copy, getopt

import path
import tarsqi
from library.main import LIBRARY

EVENT = LIBRARY.timeml.EVENT
TIMEX3 = LIBRARY.timeml.TIMEX
ALINK = LIBRARY.timeml.ALINK
SLINK = LIBRARY.timeml.SLINK
TLINK = LIBRARY.timeml.TLINK

LINK_TAGS = (ALINK, SLINK, TLINK)
TIMEML_TAGS = (EVENT, TIMEX3, ALINK, SLINK, TLINK)

TID = LIBRARY.timeml.TID
EIID = LIBRARY.timeml.EIID

RELTYPE = LIBRARY.timeml.RELTYPE
TIME_ID = LIBRARY.timeml.TIME_ID
EVENT_INSTANCE_ID = LIBRARY.timeml.EVENT_INSTANCE_ID
RELATED_TO_TIME = LIBRARY.timeml.RELATED_TO_TIME
RELATED_TO_EVENT_INSTANCE = LIBRARY.timeml.RELATED_TO_EVENT_INSTANCE
SUBORDINATED_EVENT_INSTANCE = LIBRARY.timeml.SUBORDINATED_EVENT_INSTANCE


def create_system_files_from_gold_standard(gold_dir, system_dir, limit):
    """Take the TTK files in gold_dir and create TTK files in system_dir that have
    the same text and docelement tags, do not have the other tarsqi tags from
    the gold standard and have tags as added by the current system."""
    print system_dir
    if os.path.exists(system_dir):
        exit("Error: directory %s already exists" % system_dir)
    else:
        os.makedirs(system_dir)
    # get the absolute paths now because components may change the current directory
    gold_dir = os.path.abspath(gold_dir)
    system_dir = os.path.abspath(system_dir)
    count = 0
    for fname in os.listdir(gold_dir):
        count += 1
        if count > limit:
            break
        if os.path.basename(fname) == 'wsj_0907.tml':
            # this is a hack to avoid tagging problems with a timebank file
            continue
        print fname
        gold_file = os.path.join(gold_dir, fname)
        system_file = os.path.join(system_dir, fname)
        create_system_file_from_gold_standard(gold_file, system_file)


def create_system_file_from_gold_standard(gold_file, system_file):
    tarsqi_inst, tarsqidoc = tarsqi.load_ttk_document(gold_file)
    # before you reset, keep the docelement tags so that we do not have to rerun
    # the document parser
    docelement_tags = [t for t in tarsqidoc.tags.all_tags() if t.name == 'docelement']
    tarsqidoc.tags.reset()
    for tag in docelement_tags:
        tarsqidoc.tags.append(tag)
    tarsqidoc.tags.index()
    for (name, wrapper) in tarsqi_inst.pipeline:
        #print name
        tarsqi_inst._apply_component(name, wrapper, tarsqidoc)
    tarsqi_inst.output = system_file
    # TODO: this uses a private method
    tarsqi_inst._write_output()


def compare_dirs(gold_dir, system_dir, limit=sys.maxint):
    fstats = []
    count = 0
    gold_files = os.listdir(gold_dir)
    system_files = os.listdir(system_dir)
    # don't assume the directory content is the same
    fnames = [f for f in gold_files if f in system_files]
    for fname in fnames:
        count += 1
        if count > limit:
            break
        if fname.endswith('wsj_0907.tml'):
            continue
        print fname
        fstats.append(FileStatistics(os.path.join(gold_dir, fname),
                                     os.path.join(system_dir, fname)))
    dstats = DirectoryStatistics(system_dir, fstats)
    dstats.pp()


def get_annotations(tag_repository):
    """Return a dictionary of the TimeML annotations in the tag repository."""
    timeml_tags = (EVENT, TIMEX3, ALINK, SLINK, TLINK)
    annotations = { tagname: {} for tagname in timeml_tags }
    event_idx = {}
    timex_idx = {}
    for tag in tag_repository.all_tags():
        if tag.name == EVENT:
            event_idx[tag.attrs[EIID]] = tag
        elif tag.name == TIMEX3:
            timex_idx[tag.attrs[TID]] = tag
    for tag in tag_repository.all_tags():
        if tag.name in timeml_tags:
            offsets = get_offsets(tag, event_idx, timex_idx)
            if offsets is not None:
                annotations[tag.name][offsets] = tag.attrs
    return annotations


def get_offsets(tag, event_idx, timex_idx):
    """Get begin and end offsets for the tag. For an event or time, this is a pair
    of offsets, for example (13,16). For a link, this is pair of the offsets of
    the source and target of the link, for example ((13,16),(24,29))."""
    def retrieve_from_index(identifier):
        idx = event_idx if identifier[0] == 'e' else timex_idx
        try:
            return (idx[identifier].begin, idx[identifier].end)
        except KeyError:
            return (None, None)
    if tag.name in LINK_TAGS:
        ids = (tag.attrs.get(TIME_ID),
               tag.attrs.get(EVENT_INSTANCE_ID),
               tag.attrs.get(RELATED_TO_TIME),
               tag.attrs.get(RELATED_TO_EVENT_INSTANCE),
               tag.attrs.get(SUBORDINATED_EVENT_INSTANCE))
        ids = [i for i in ids if i is not None]
        offsets = [retrieve_from_index(i) for i in ids if i is not None]
        if len(offsets) != 2:
            print "WARNING: unexpected offsets"
            print "         %s" % tag.as_ttk_tag()
            return None
        elif offsets[0][0] is None or offsets[1][0] is None:
            print "WARNING: cannot find source and/or target"
            print "         %s" % tag.as_ttk_tag()
            return None
        else:
            return tuple(offsets)
    else:
        return (tag.begin, tag.end)


def print_annotations(annotations, tag=None):
    for tagname in sorted(annotations):
        if tag is not None and tag != tagname:
            continue
        print "\n", tagname
        for offsets in sorted(annotations[tagname]):
            attrs = annotations[tagname][offsets].items()
            attrs_str = ' '.join(["%s=%s" % (a,v) for a,v in attrs])
            print "  %s %s" % (offsets, attrs_str)


class FileStatistics(object):

    def __init__(self, gold_file, system_file):
        gold_tags = self._get_tags(gold_file)
        system_tags = self._get_tags(system_file)
        self.filename = system_file
        self.gold = get_annotations(gold_tags)
        self.system = get_annotations(system_tags)
        self.events = EntityStatistics(self.filename, EVENT, self.gold, self.system)
        self.timexes = EntityStatistics(self.filename, TIMEX3, self.gold, self.system)
        self.alinks = LinkStatistics(self.filename, ALINK, self.gold, self.system)
        self.slinks = LinkStatistics(self.filename, SLINK, self.gold, self.system)
        self.tlinks = LinkStatistics(self.filename, TLINK, self.gold, self.system)

    def __str__(self):
        return "%s\n%s\n%s\n%s\n%s" % (self.events, self.timexes,
                                       self.alinks, self.slinks, self.tlinks)

    @staticmethod
    def _get_tags(fname):
        """Return the TagRepository for fname."""
        tarsqi_inst, tarsqidoc = tarsqi.load_ttk_document(fname)
        return tarsqidoc.tags


class DirectoryStatistics(FileStatistics):

    def __init__(self, directory, statslist):
        self.filename = directory
        self.statistics = statslist
        self.events = AggregateEntityStatistics(directory, [s.events for s in statslist])
        self.timexes = AggregateEntityStatistics(directory, [s.timexes for s in statslist])
        self.alinks = AggregateLinkStatistics(directory, [s.alinks for s in statslist])
        self.slinks = AggregateLinkStatistics(directory, [s.slinks for s in statslist])
        self.tlinks = AggregateLinkStatistics(directory, [s.tlinks for s in statslist])

    def __str__(self):
        return "%s\n%s\n%s\n%s\n%s" % (
            self.events, self.timexes, self.alinks, self.slinks, self.tlinks)

    def pp(self):
        print "\n%s\n" % self


class EntityStatistics(object):

    def __init__(self, filename, tagname, gold_annotations, system_annotations):
        self.filename = filename
        self.tagname = tagname
        self.gold = gold_annotations[tagname]
        self.system = system_annotations[tagname]
        self.tp = 0
        self.fp = 0
        self.fn = 0
        self._collect_counts()

    def _collect_counts(self):
        """Collect the counts for true positive, false positive and false negative."""
        for t in self.system.keys():
            if t in self.gold:
                self.tp += 1
            else:
                self.fp += 1
        for t in self.gold.keys():
            if t not in self.system:
                self.fn += 1

    def __str__(self):
        p = self.precision()
        r = self.recall()
        f= self.fscore()
        p = "%.2f" % p if p is not None else 'nil'
        r = "%.2f" % r if r is not None else 'nil'
        f = "%.2f" % f if f is not None else 'nil'
        return "<Statistics %s %s tp:%s fp:%s fn:%s precision=%s recall=%s f-score=%s>" % \
            (self.tagname, self.filename, self.tp, self.fp, self.fn, p, r, f)

    def precision(self):
        try:
            return float(self.tp) / (self.tp + self.fp)
        except ZeroDivisionError:
            return None

    def recall(self):
        try:
            return float(self.tp) / (self.tp + self.fn)
        except ZeroDivisionError:
            return None

    def fscore(self):
        p = self.precision()
        r = self.recall()
        if p is None or r is None:
            return None
        return (2 * p * r) / (p + r)


class LinkStatistics(object):

    def __init__(self, filename, tagname, gold_annotations, system_annotations):
        self.filename = filename
        self.tagname = tagname
        self.gold = gold_annotations[tagname]
        self.system = system_annotations[tagname]
        self.overlap = overlap(self.gold, self.system)
        #print self.gold.keys()
        #print self.system.keys()
        #print self.overlap
        self.correct = 0
        self.incorrect = 0
        for offset in self.overlap:
            if self.gold[offset][RELTYPE] == self.system[offset][RELTYPE]:
                self.correct += 1
            else:
                self.incorrect += 1

    def __str__(self):
        accuracy = self.accuracy()
        astring = "nil" if accuracy is None else "%.2f" % accuracy
        return "<Statistics %s %s correct:%s incorrect:%s accuracy:%s>" % \
            (self.tagname, self.filename, self.correct, self.incorrect, astring)

    def accuracy(self):
        try:
            return float(self.correct) / (self.correct + self.incorrect)
        except ZeroDivisionError:
            return None


class AggregateEntityStatistics(EntityStatistics):

    def __init__(self, directory, statistics_list):
        self.tagname = statistics_list[0].tagname
        self.filename = directory
        self.statistics = statistics_list
        self.tp = sum([stats.tp for stats in statistics_list])
        self.fp = sum([stats.fp for stats in statistics_list])
        self.fn = sum([stats.fn for stats in statistics_list])


class AggregateLinkStatistics(LinkStatistics):

    def __init__(self, directory, statistics_list):
        self.tagname = statistics_list[0].tagname
        self.filename = directory
        self.statistics = statistics_list
        self.correct = sum([stats.correct for stats in statistics_list])
        self.incorrect = sum([stats.incorrect for stats in statistics_list])


def overlap(annotations1, annotations2):
    """Now just gets the keys that both have in common, should include links where
    source and target are reversed."""
    return [val for val in annotations1 if val in annotations2]



if __name__ == '__main__':

    options = ['run-system', 'compare' , 'gold=', 'system=', 'limit=']
    (opts, args) = getopt.getopt(sys.argv[1:], '', options)
    opts = { k:v for k,v in opts }

    gold =  opts.get('--gold')
    system =  opts.get('--system')
    limit = opts.get('--limit', sys.maxint)

    if opts.has_key('--run-system'):
        create_system_files_from_gold_standard(gold, system, limit)
    elif opts.has_key('--compare'):
        compare_dirs(gold, system, limit)
