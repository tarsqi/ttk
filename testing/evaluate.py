"""evaluate.py

Script to create a system response for a given gold standard and then compare
the system response to that gold standard.

USAGE:

$ python evaluate.py --run-system --gold DIR1 --system DIR2 (--limit INT)
$ python evaluate.py --compare --gold DIR1 --system DIR2 (--limit INT)

In the first invocation, the script takes the gold standard files in DIR1 and
for each file creates a system file in DIR2 that does not have the gold standard
tags but the tags generated by the system. In the second invocation, the script
compares the system results to the gold standard. Both invocations have an
optional --limit parameter which caps the number of files processed from the
directory. If no limit is given all files will be processed.

In both cases, all files in the gold standard are expected to be TTK files. See
the code in utilities.convert for how to convert to the TTK format.

"""

import os, sys, copy, getopt

sys.path.insert(0, '..')

import tarsqi
from library.main import LIBRARY

EVENT = LIBRARY.timeml.EVENT
TIMEX = LIBRARY.timeml.TIMEX
ALINK = LIBRARY.timeml.ALINK
SLINK = LIBRARY.timeml.SLINK
TLINK = LIBRARY.timeml.TLINK

LINK_TAGS = (ALINK, SLINK, TLINK)
TIMEML_TAGS = (EVENT, TIMEX, ALINK, SLINK, TLINK)

TID = LIBRARY.timeml.TID
EIID = LIBRARY.timeml.EIID

RELTYPE = LIBRARY.timeml.RELTYPE
TIME_ID = LIBRARY.timeml.TIME_ID
EVENT_INSTANCE_ID = LIBRARY.timeml.EVENT_INSTANCE_ID
RELATED_TO_TIME = LIBRARY.timeml.RELATED_TO_TIME
RELATED_TO_EVENT_INSTANCE = LIBRARY.timeml.RELATED_TO_EVENT_INSTANCE
SUBORDINATED_EVENT_INSTANCE = LIBRARY.timeml.SUBORDINATED_EVENT_INSTANCE


def create_system_files_from_gold_standard(gold_dir, system_dir, limit):
    """Take the TTK files in gold_dir and create TTK files in system_dir that have
    the same text and docelement tags, do not have the other tarsqi tags from
    the gold standard and have tags as added by the current system."""
    print system_dir
    if os.path.exists(system_dir):
        exit("Error: directory %s already exists" % system_dir)
    else:
        os.makedirs(system_dir)
    # get the absolute paths now because components may change the current directory
    gold_dir = os.path.abspath(gold_dir)
    system_dir = os.path.abspath(system_dir)
    count = 0
    for fname in os.listdir(gold_dir):
        count += 1
        if count > limit:
            break
        print fname
        gold_file = os.path.join(gold_dir, fname)
        system_file = os.path.join(system_dir, fname)
        create_system_file_from_gold_standard(gold_file, system_file)


def create_system_file_from_gold_standard(gold_file, system_file):
    # TODO: need to deal with the fact that with THYME we have a ttk version and
    # we use source=ttk, but there really needs to be a metadata parser that
    # does works for THYME documents. One option is to have the conversion find
    # the DCT.
    tarsqi_inst, tarsqidoc = tarsqi.load_ttk_document(gold_file)
    # before you reset, keep the docelement tags so that we do not have to rerun
    # the document parser
    docelement_tags = [t for t in tarsqidoc.tags.all_tags() if t.name == 'docelement']
    tarsqidoc.tags.reset()
    for tag in docelement_tags:
        tarsqidoc.tags.append(tag)
    tarsqidoc.tags.index()
    for (name, wrapper) in tarsqi_inst.pipeline:
        tarsqi_inst._apply_component(name, wrapper, tarsqidoc)
    tarsqi_inst.output = system_file
    # TODO: this uses a private method
    tarsqi_inst._write_output()


def compare_dirs(gold_dir, system_dir, limit=sys.maxint):
    fstats = []
    count = 0
    gold_files = os.listdir(gold_dir)
    system_files = os.listdir(system_dir)
    # don't assume the directory content is the same
    fnames = [f for f in gold_files if f in system_files]
    for fname in fnames:
        count += 1
        if count > limit:
            break
        if fname.endswith('wsj_0907.tml'):
            continue
        print fname
        fstats.append(FileStatistics(os.path.join(gold_dir, fname),
                                     os.path.join(system_dir, fname)))
    dstats = DirectoryStatistics(system_dir, fstats)
    dstats.pp()


def get_annotations(tag_repository):
    """Return a dictionary of the TimeML annotations in the tag repository."""
    timeml_tags = (EVENT, TIMEX, ALINK, SLINK, TLINK)
    annotations = { tagname: {} for tagname in timeml_tags }
    event_idx = {}
    timex_idx = {}
    for tag in tag_repository.all_tags():
        if tag.name == EVENT:
            event_idx[tag.attrs[EIID]] = tag
        elif tag.name == TIMEX:
            timex_idx[tag.attrs[TID]] = tag
    for tag in tag_repository.all_tags():
        if tag.name in timeml_tags:
            offsets = get_offsets(tag, event_idx, timex_idx)
            if offsets is not None:
                annotations[tag.name][offsets] = tag.attrs
    return annotations


def get_offsets(tag, event_idx, timex_idx):
    """Get begin and end offsets for the tag. For an event or time, this is a pair
    of offsets, for example (13,16). For a link, this is pair of the offsets of
    the source and target of the link, for example ((13,16),(24,29))."""
    if tag.name in LINK_TAGS:
        id1, id1_type = tag.attrs.get(TIME_ID), TIMEX
        if id1 is None:
            saved = "%s-%s" % (id1, id1_type)
            id1, id1_type = tag.attrs.get(EVENT_INSTANCE_ID), EVENT
        id2, id2_type = tag.attrs.get(RELATED_TO_TIME), TIMEX
        if id2 is None:
            id2, id2_type = tag.attrs.get(RELATED_TO_EVENT_INSTANCE), EVENT
        if id2 is None:
            id2, id2_type = tag.attrs.get(SUBORDINATED_EVENT_INSTANCE), EVENT
        offsets = [_retrieve_from_index(id1, id1_type, event_idx, timex_idx),
                   _retrieve_from_index(id2, id2_type, event_idx, timex_idx)]
        if len(offsets) != 2:
            _offset_warning("unexpected offsets", tag, offsets)
            return None
        elif offsets[0][0] is None or offsets[1][0] is None:
            _offset_warning("cannot find source and/or target", tag, offsets)
            return None
        else:
            return tuple(offsets)
    else:
        return (tag.begin, tag.end)


def _retrieve_from_index(identifier, tagtype, event_idx, timex_idx):
    idx = event_idx if tagtype == EVENT else timex_idx
    try:
        return (idx[identifier].begin, idx[identifier].end)
    except KeyError:
        return (None, None)


def _offset_warning(message, tag, offsets):
    print "WARNING: %s" % message
    print "         %s" % offsets
    print "         %s" % tag.as_ttk_tag()


def print_annotations(annotations, tag=None):
    for tagname in sorted(annotations):
        if tag is not None and tag != tagname:
            continue
        print "\n", tagname
        for offsets in sorted(annotations[tagname]):
            attrs = annotations[tagname][offsets].items()
            attrs_str = ' '.join(["%s=%s" % (a,v) for a,v in attrs])
            print "  %s %s" % (offsets, attrs_str)


class FileStatistics(object):

    def __init__(self, gold_file, system_file):
        gold_tags = self._get_tags(gold_file)
        system_tags = self._get_tags(system_file)
        self.filename = system_file
        self.gold = get_annotations(gold_tags)
        self.system = get_annotations(system_tags)
        self.events = EntityStatistics(self.filename, EVENT, self.gold, self.system)
        self.timexes = EntityStatistics(self.filename, TIMEX, self.gold, self.system)
        self.alinks = LinkStatistics(self.filename, ALINK, self.gold, self.system)
        self.slinks = LinkStatistics(self.filename, SLINK, self.gold, self.system)
        self.tlinks = LinkStatistics(self.filename, TLINK, self.gold, self.system)

    def __str__(self):
        return "%s\n%s\n%s\n%s\n%s" % (self.events, self.timexes,
                                       self.alinks, self.slinks, self.tlinks)

    @staticmethod
    def _get_tags(fname):
        """Return the TagRepository for fname."""
        tarsqi_inst, tarsqidoc = tarsqi.load_ttk_document(fname)
        return tarsqidoc.tags


class DirectoryStatistics(FileStatistics):

    def __init__(self, directory, statslist):
        self.filename = directory
        self.statistics = statslist
        self.events = AggregateEntityStatistics(directory, [s.events for s in statslist])
        self.timexes = AggregateEntityStatistics(directory, [s.timexes for s in statslist])
        self.alinks = AggregateLinkStatistics(directory, [s.alinks for s in statslist])
        self.slinks = AggregateLinkStatistics(directory, [s.slinks for s in statslist])
        self.tlinks = AggregateLinkStatistics(directory, [s.tlinks for s in statslist])

    def __str__(self):
        return "%s\n%s\n%s\n%s\n%s" % (
            self.events, self.timexes, self.alinks, self.slinks, self.tlinks)

    def pp(self):
        print "\n%s\n" % self


class EntityStatistics(object):

    def __init__(self, filename, tagname, gold_annotations, system_annotations):
        self.filename = filename
        self.tagname = tagname
        self.gold = gold_annotations[tagname]
        self.system = system_annotations[tagname]
        self.tp = 0
        self.fp = 0
        self.fn = 0
        self._collect_counts()

    def _collect_counts(self):
        """Collect the counts for true positive, false positive and false negative."""
        for t in self.system.keys():
            if t in self.gold:
                self.tp += 1
            else:
                self.fp += 1
        for t in self.gold.keys():
            if t not in self.system:
                self.fn += 1

    def __str__(self):
        p = self.precision()
        r = self.recall()
        f = self.fscore()
        p = "%.2f" % p if p is not None else 'nil'
        r = "%.2f" % r if r is not None else 'nil'
        f = "%.2f" % f if f is not None else 'nil'
        return "<Statistics %s %s tp:%s fp:%s fn:%s precision=%s recall=%s f-score=%s>" % \
            (self.tagname, self.filename, self.tp, self.fp, self.fn, p, r, f)

    def precision(self):
        try:
            return float(self.tp) / (self.tp + self.fp)
        except ZeroDivisionError:
            return None

    def recall(self):
        try:
            return float(self.tp) / (self.tp + self.fn)
        except ZeroDivisionError:
            return None

    def fscore(self):
        p = self.precision()
        r = self.recall()
        if p is None or r is None:
            return None
        try:
            return (2 * p * r) / (p + r)
        except ZeroDivisionError:
            return None


class LinkStatistics(object):

    def __init__(self, filename, tagname, gold_annotations, system_annotations):
        self.filename = filename
        self.tagname = tagname
        self.gold = gold_annotations[tagname]
        self.system = system_annotations[tagname]
        self.overlap = overlap(self.gold, self.system)
        self.correct = 0
        self.incorrect = 0
        for offset in self.overlap:
            if self.gold[offset][RELTYPE] == self.system[offset][RELTYPE]:
                self.correct += 1
            else:
                self.incorrect += 1

    def __str__(self):
        accuracy = self.accuracy()
        astring = "nil" if accuracy is None else "%.2f" % accuracy
        return "<Statistics %s %s correct:%s incorrect:%s accuracy:%s>" % \
            (self.tagname, self.filename, self.correct, self.incorrect, astring)

    def accuracy(self):
        try:
            return float(self.correct) / (self.correct + self.incorrect)
        except ZeroDivisionError:
            return None


class AggregateEntityStatistics(EntityStatistics):

    def __init__(self, directory, statistics_list):
        self.tagname = statistics_list[0].tagname
        self.filename = directory
        self.statistics = statistics_list
        self.tp = sum([stats.tp for stats in statistics_list])
        self.fp = sum([stats.fp for stats in statistics_list])
        self.fn = sum([stats.fn for stats in statistics_list])


class AggregateLinkStatistics(LinkStatistics):

    def __init__(self, directory, statistics_list):
        self.tagname = statistics_list[0].tagname
        self.filename = directory
        self.statistics = statistics_list
        self.correct = sum([stats.correct for stats in statistics_list])
        self.incorrect = sum([stats.incorrect for stats in statistics_list])


def overlap(annotations1, annotations2):
    """Now just gets the keys that both have in common, should include links where
    source and target are reversed."""
    return [val for val in annotations1 if val in annotations2]


if __name__ == '__main__':

    options = ['run-system', 'compare' , 'gold=', 'system=', 'limit=']
    (opts, args) = getopt.getopt(sys.argv[1:], '', options)
    opts = { k:v for k,v in opts }

    gold = os.path.abspath(opts.get('--gold'))
    system = os.path.abspath(opts.get('--system'))
    limit = int(opts.get('--limit', sys.maxint))

    if '--run-system' in opts:
        create_system_files_from_gold_standard(gold, system, limit)
    elif '--compare' in opts:
        compare_dirs(gold, system, limit)
